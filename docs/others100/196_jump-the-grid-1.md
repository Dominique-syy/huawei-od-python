# 196 跳格子（1）

## 题目描述

地上共有`N`个格子，你需要跳完地上所有的格子，但是格子间是有强依赖关系的，跳完前一个格子后，后续的格子才会被开启，格子间的依赖关系由多组`steps`数组给出，`steps[0]`表示前一个格子，`steps[1]`表示`steps[0]`可以开启的格子：

- 比如`[0,1]`表示从跳完第0个格子以后，第1个格子就开启了。
- 比如`[2,1]`、`[2,3]`表示跳完第2个格子后，第1个格子和第3个格子就被开启了。

请你计算是否能由给出的`steps`数组跳完所有的格子，如果可以输出`yes`，否则输出`no`。

**说明：**

1. 你可以从一个格子跳到任意一个开启的格子。
2. 没有前置依赖条件的格子默认就是开启的。
3. 如果总数是`N`，则所有的格子编号为`[0, 1, 2, 3, ..., N-1]`连续的数组。

其中：
- 1 <= N < 500
- steps[i].length = 2
- 0 <= step[i][0], step[i][1] < N

## 输入描述

输入一个整数`N`，表示总共的格子数量。

接着输入多组二维数组`steps`，表示所有格子之间的依赖关系。

## 输出描述

如果能按照`steps`给定的依赖顺序跳完所有的格子，输出`yes`，否则输出`no`。

## 示例描述

### 示例一

**输入：**

```text
3
0 1
0 2
```

**输出：**

```text
yes
```

**说明：**

总共有3个格子`[0,1,2]`，跳完0个格子后第1个格子就开启了，跳到第0个格子后第2个格子也被开启了。

按照`0->1->2`或者`0->2->1`的顺序都可以跳完所有的格子，所以，输出`yes`。

### 示例二

**输入：**

```text
2
1 0
0 1
```

**输出：**

```text
no
```

**说明：**

总共有2个格子，第1个格子可以开启第0个格子，但是第1个格子又需要第0个格子才能开启，相互依赖，因此无法完成。

### 示例三

**输入：**

```text
6
0 1
0 2
0 3
0 4
0 5
```

**输出：**

```text
yes
```

**说明：**

总共有6个格子，第0个格子可以开启第1、2、3、4、5个格子，所以跳完第0个格子之后，其他格子都被开启了，之后按照任意顺序都可以跳完剩余的格子。

### 示例四

**输入：**

```text
5
4 3
0 4
2 1
3 2
```

**输出：**

```text
yes
```

**说明：**

跳完第0个格子可以开启格子4，跳完格子4可以开启格子3，跳完格子3可以开启格子2，跳完格子2可以开启格子1，按照`0->4->3->2->1`这样就能跳完所有的格子。

### 示例五

**输入：**

```text
4
1 2
1 0
```

**输出：**

```text
yes
```

**说明：**

总共4个格子`[0,1,2,3]`，格子1和格子3没有前置条件，所以默认开启，格子1可以开启格子0和格子2，所以跳到格子1之后就可以开启所有的格子，因此可以跳完所有格子。

## 解题思路

本题的目标是实现了一个跳格子游戏的逻辑，核心思路是利用栈和字典，按照行列分别存储已经走过的格子，然后遍历每一个空白格子，判断它是否可以到达边界，最后判断是否所有的空白格子都不能到达边界，从而判断游戏是否可以成功。

## 解题代码

```python
from typing import List


def skip_grid(n: int，grids : List[List[int]])-> bool:
    x =[None] * n
    map = {}
    for i in range (len(grids)) :
        a = grids[i]
        if a[0] not in map:
            map[a[0]] =[]
        map[a[0] ] . append(a[1])
        x[a[1]] = a[0]
    stack =[]
    for i in range(n):
        if x[i] is None:
            stack. append(i)
    if not stack:
        return False
    while stack:
        index = stack. pop()
        x[index] = -1
        if index not in map:
            continue
            for item in map[index]:
                if x[item] != -1:
                    stack. append(item)
    return all(val -= -1 for val in x)  


if __name__ == '__main__':
    n = 2
    grids =[[1,0]，[0，1]]
    r = skip_grid(n, grids)
    print( "yes" if r else "no")
```

