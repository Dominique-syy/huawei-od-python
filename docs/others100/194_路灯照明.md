# 194路灯照明

## 题目描述

在一条笔直的公路上安装了N个路灯，
从位置0开始安装，路灯之间间距固定为100米
每个路灯都有自己的照明半径
请计算第一个路灯和最后一个路灯之间，
无法照明的区间的长度和。

## 输入描述

第一行为一个数N，表示路灯个数，1 <= N <= 100000
第二行为N个空格分割的数，表示路灯的照明半径，1 =照明半径

## 输出描述

无法照明的区间的长度和

## 示例描述

### 示例一

**输入：**

```shell
2
50 50
```

**输出：**

```shell
0
```

**说明：**

1. 路灯1覆盖0-50路灯二覆盖50-100
2. 路灯1和路灯2之间(O-100米)无未覆盖的区间

## 解题思路

本题的目的是解决以下问题:给定一个包含n个整数的数组，每个整数代表一个圆的半径，将这些圆画在平面直角坐标系中，求坐标系中没有被任何圆覆盖的点的数量。

1. 输入整数n和包含n个整数的数组 ints 。
2. 用 bytearray 类型的变量bytes_创建一个长度为(n-1)*100的字节数组，用于表示每个点是否被圆覆盖。初始值为О，表示所有点都未被覆盖。
3. 对于数组 ints 中的每个整数，计算其对应圆覆盖的区域，并将这个区域中的所有点在 bytes_ 中标记为1，表示这些点已被覆盖。
4. 统计 bytes_中值为0的元素个数，即为未被任何圆覆盖的点的数量。

## 解题代码

```python
def main():
    n = int(input())
    ints = list(map(int, input().split()))
    solve_method(ints)


def solve_method(ints):
    bytes_ = bytearray((len(ints) - 1) * 100)

    for i in range(len(ints)):
        pos = i * 100
        left = max(pos - ints[i], 0)
        right = min(pos + ints[i], len(bytes_))

        for k in range(left, right):
            bytes_[k] = 1

    count = bytes_.count(0)
    print(count)



main()
```

