# 029 出错的或电路

## 题目描述

某生产门电路的厂商发现某一批次的或门电路不稳定，具体现象为计算两个二进制数的或操作时，第一个二进制数中某两个比特位会出现交换，交换的比特位置是随机的，但只交换这两个位，其他位不变。很明显，这个交换可能会影响最终的或结果，也可能不会有影响。

为了评估影响和定位出错的根因，工程师需要研究在各种交换的可能下，最终的或结果发生改变的情况有多少种。

## 输入描述

第一行有一个正整数`N`，其中1 <= N <= 1000000。

第二行有一个长为`N`的二进制数，表示或电路的第一个输入数，即会发生比特交换的输入数。

第三行有一个长为`N`的二进制数，表示或电路的第二个输入数。注意第二个输入数不会发生比特交换。

## 输出描述

输出只有一个整数，表示会影响或结果的交换方案个数。

## 示例描述

### 示例一

**输入：**

```text
3
010
110
```

**输出：**

```text
1
```

**说明：**

原本`010`和`110`的或结果是`110`，但第一个输入数可能会发生如下三种交换：

- 交换第1个比特和第2个比特，第一个输入数变为`100`，计算结果为`110`，计算结果不变。
- 交换第1个比特和第3个比特，第一个输入数变为`010`，计算结果为`110`，计算结果不变。  
- 交换第2个比特和第3个比特，第一个输入数变为`001`，计算结果为`111`，计算结果改变。

故只有1种交换会改变计算结果。

### 示例二

**输入：**

```text
6
011011
110110
```

**输出：**

```text
4
```

**说明：**

原本`011011`和`110110`的或结果是`111111`，但第一个输入数发生如下比特交换会影响最终计算结果：

- 交换第1个比特和第3个比特，第一个输入数变为`110011`，计算结果变为`110111`。
- 交换第1个比特和第6个比特，第一个输入数变为`111010`，计算结果变为`111110`。
- 交换第3个比特和第4个比特，第一个输入数变为`010111`，计算结果变为`110111`。
- 交换第4个比特和第6个比特，第一个输入数变为`011110`，计算结果变为`111110`。

其他的交换都不会影响计算结果，故输出4。

## 解题思路

1. 计算两个数的原始或运算的结果`value`。
2. 使用两个遍历，分别遍历比特位索引：
    - 交换两个比特位。
    - 计算交换后的结果。
    - 检查结果是否发生改变，如果发生改变，结果`count`累加1。
3. 返回`count`结果。    

## 解题代码

```Python
def solve_method(binary1, binary2):
    count = 0
    length = len(binary1)

    value = int(binary1, 2) | int(binary2, 2)
    # 遍历比特位索引
    for i in range(length):
        for j in range(i, length):
            # 交换两个比特位
            binary1_list = list(binary1)
            binary1_list[i], binary1_list[j] = binary1_list[j], binary1_list[i]

            # 计算交换后的结果
            binary1_str = "".join(binary1_list)
            result = int(binary1_str, 2) | int(binary2, 2)

            # 检查结果是否发生改变
            if result != value:
                count += 1

    return count


if __name__ == '__main__':
    assert solve_method("010", "110") == 1
    assert solve_method("011011", "110110") == 4
    assert solve_method("110", "001") == 2
```



