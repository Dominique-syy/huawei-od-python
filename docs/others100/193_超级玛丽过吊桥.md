# 193超级玛丽过吊桥

## 题目描述

超级玛丽好不容易来到新的一关，有一个长长的吊桥，吊桥的尽头是下水管道，其中随机的木板存在缺失，一旦踩到就会死亡，死亡后如果还有剩余的生命将在原地复活且不受木板缺失影响，但会消耗一次生命
如果跨过了管道，将跌入悬崖，通关失败。

超级玛丽从起点S开始，可以走到下一个木板(计1)，也可以跳着跨过一个块(计2)或两个木板(计3)，最终必须刚好走到终点E。
现在给定超级玛丽当前的生命数M，吊桥的长度N，缺失的木板数K，以及随机缺失的木板编号数组L，请帮忙计算一下，超级玛丽有多少种方法可以通过此关。

## 输入描述

超级玛丽当前生命数:M(1 <=M<=5，整数)
吊桥的长度:N(1 <=N<= 32，整数)
缺失木板数:K(1 <=N<= 32，整数)
缺失木板编号数组:L (长度及编号的内容不大于N的编号数组， 1<= L;<= N，由空格分隔的整数数组)

## 输出描述

输出通过此关的吊桥走法个数，如果不能通过此关，请输出0

## 示例描述

### 示例一

**输入：**

```shell
2 2 1
2
```

**输出：**

```shell
4
```

**说明：**

2个生命，2个木板，缺失1个木板
第2个木板有缺失，一共有4种走法：

1. 3
2. 1 2

## 解题思路

1. `def solve(M, N, K, trap):`: 定义一个函数 `solve`，接受四个参数：`M` 表示每次可以移动的最大步数，`N` 表示桥梁的长度，`K` 表示陷阱的数量，`trap` 是一个包含陷阱位置的列表。
2. 初始化 `bridge` 列表，长度为 `N + 2`，表示桥梁的状态，初始化时都为可通行状态（`True`）。
3. 遍历陷阱位置列表 `trap`，将对应的桥梁位置设置为不可通行状态（`False`）。
4. 初始化 `dp` 列表，是一个二维列表，表示状态转移表。`dp[i][j]` 表示在第 `i` 个位置，还剩余 `j` 步可移动的方案数。初始化时，起点位置 `dp[0][M]` 设置为1，表示从起点出发，剩余 `M` 步的方案数为1。
5. 使用两个嵌套循环遍历状态转移表 `dp`：
   - 在循环内部，首先计算 `k`，即下一步的位置。如果当前位置是陷阱，则下一步位置不变，否则加1。
   - 根据状态转移方程计算 `dp[i][j]`。当 `i` 小于等于2 时，分别考虑上一步、上两步的方案数。当 `i` 大于2 时，考虑上一步、上两步、上三步的方案数。
6. 计算最终结果，将 `dp[N + 1]` 列表中前 `len(dp[0]) - 1` 项的和，表示从终点出发的路径数量。
7. 返回结果。
8. 在 `if __name__ == "__main__":` 块中：
   - 从输入读取三个整数 `M`、`N` 和 `K`，表示每次移动的步数、桥梁长度和陷阱数量。
   - 从输入读取陷阱位置列表 `trap`。
   - 调用 `solve` 函数，计算并获得最终结果。
   - 输出结果。

## 解题代码

```python
def solve(M, N, K, trap):
    bridge = [True] * (N + 2)
    for i in range(K):
        bridge[trap[i]] = False

    dp = [[0] * (M + 2) for _ in range(N + 2)]
    dp[0][M] = 1

    for i in range(1, len(dp)):
        for j in range(1, len(dp[0]) - 1):
            k = j + 1 if not bridge[i] else j
            if i == 1:
                dp[i][j] = dp[i - 1][k]
            elif i == 2:
                dp[i][j] = dp[i - 1][k] + dp[i - 2][k]
            else:
                dp[i][j] = dp[i - 1][k] + dp[i - 2][k] + dp[i - 3][k]
    res = sum(dp[N + 1][: len(dp[0]) - 1])
    return res


if __name__ == "__main__":
    M,N,K = map(int, input().split())
    trap = list(map(int, input().split()))
    s = solve(M, N, K, trap)
    print(s)
```

