# 006-RSA加密算法

## 题目描述

RSA加密算法在网络安全世界中无处不在
它利用了极大整数因数分解的困难度，数据越大安全系数越高
给定了一个32位正整数，请对其进行因数分解
找出哪两个素数的乘积

## 输入描述

一个正整数num
0 < num <= 2147483647

## 输出描述

如果成功找到以单个空格分割
从小到大输出两个素数
分解失败请输出-1 -1

## 示例描述

### 示例一

**输入：**
```shell
15
```

**输出：**
```shell
3 5
```

**说明：**  
因数分解后3*5=15
从小到大后输出3 5

## 解题思路

给定一个正整数，需要找出它的两个因数使得它们的乘积等于原数。如果找不到这样的两个因数，则输出-1-1。
这个问题可以通过分解质因数Q的方式得到所有的因数，然后在这些因数中寻找满足要求的因数。通过st可以去重。

###核心知识点

分解质因数：每个正整数都可以分解成若干个质数的积的形式。分解的过程是不断地将这个数除以最小的质数，
然后将得到的商继续除以最小的质数，直到商为1。在这个过程中，所得到的所有质数就是这个正整数的所有质因数。
例如，36可以分解成2 * 2 * 3 * 3的形式。
集合(set)：在Python中，set是一种无序的、元素不重复的数据结构。可以用set()函数来创建一个空集合，或者用花括号来创建
一个非空集合。集合支持交、并、差等操作。

## 解题代码

```python
def solve_method(num):
    # 定义空集合存储因子
    factors=set()
    tmp = num
    # 初始因子为2
    f = 2
    while tmp != 1:
        # 判断tmp是否能被f整除
        if tmp % f != 0:
            # 不能则加1
            f+=1
        else:
            # 将可以整除的因子加入set中
            factors.add(f)
            # 求商
            tmp //f
    # 双重循环判断两个因子乘积是否为num
    for f1 in factors:
        for f2 in factors:
            if f1 * f2 == num:
                min_factor = min(f1,f2)
                max_factor = max(f1,f2)
                # 格式化输出
                print(f"{min_factor}{max_factor}")
                return
    print("-1 -1")

if __name__ == "__main__":
    num = int(input())
    solve_method(num)
```

