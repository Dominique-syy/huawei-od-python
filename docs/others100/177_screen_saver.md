# 177 经典屏保

## 题目描述

DVD机在视频输出时，为了保护电视显像管，在待机状态会显示`屏保动画`，DVD `Logo`在屏幕内来回运动，碰到边缘会反弹，请根据如下要求，实现屏保 `Logo` 坐标的计算算法：

1. 屏幕是一个`800*600`像素的矩形，规定屏幕的左上角点坐标原点，沿横边向右方向为X轴，沿竖边向下方向为Y轴;
2. `Logo`是一个`50*25`像素的矩形，初始状态下，左上角点坐标记做`(x，)`，它在`X`和`Y`方向上均以`1像素/秒`的速度开始运动;
3. 遇到屏幕四个边缘后，会发生镜面反弹，即以`45°`碰撞边缘，再改变方向以`45°`弹出
4. 当`Logo`和四个角碰撞时，两个边缘同时反弹的效果是Logo会原路返回。

请编码实现， `t`秒后 `Logo` 左上角点的坐标



## 输入描述

输入`3`个数字，以空格分隔：`x y t`

第一个数字表示`Logo`左上角点的初始`X`坐标;

第二个数字表示`Logo`左上角点的初始`Y`坐标;

第三个数字表示时间`t`，题目要求即求`t`秒后`Logo`左上角点的位置.



## 输出描述

输出`2`个数字，以空格分隔：`x y`

第一个数字表示`t`秒后，`Logo`左上角点的`X`坐标

第二个数字表示`t`秒后，`Logo`左上角点的`Y`坐标

## 说明

所有用例均保证:
1、输入的`x`和`y`坐标会保证整个`Logo`都在屏幕范围内，`Logo`不会出画;
2、所有输入数据都是合法的数值，且不会出现负数;
3、`t`的最大值为`100000`。

## 示例描述

### 示例一

**输入：**

```text
0 0 10
```



**输出：**

```text
10 10
```

**说明：**

输入样例表示`Logo`初始位置在屏幕的左上角点，`10s`后，`Logo`在`X`和`Y`方向都移动了`10`像素，因此输出`10 10`。



### 示例二

**输入：**

```text
500 570 10
```



**输出：**

```text
510 570
```

**说明：**

输入样例表示初始状态下，`Logo`的下边缘再有`5像素`就碰到屏幕下边缘了，`5s`后，会与屏幕碰撞，碰撞后，斜向`45°`弹出，又经过`5s`后，`Logo` 与起始位置相比，水平移动了`10像素`，垂直方向回到了原来的高度。



## 解题思路

**基本思路：**

站在单个x或者y的维度上，我们可以知道实际上他们在做循环运动，以x在原点为例，右移到碰右壁直到返回碰左壁，实际上为一个周期，碰左壁后再往右走则为下一个周期了，y的规律是类似的。

那么我们先把x和y运动后走的离原点的总距离求出来，按周期取模即可。

取模后的值，小于等于一半，则logo为正向走，或者刚好碰壁，现在的值为距离远点的真实值，不用变。

取模后的值，大于一半的值，则logo要逆向走，则用一个周期的长度减去现在的值，即求得距离原点的真实距离。

除此之外，也可以模拟全过程，需要在每次达到墙壁时，变换方向。



## 解题代码

```python
# 整体考虑
def solve_method1(s):
    # 题目提供的默认常量
    screen_width = 800
    screen_length = 600
    logo_width = 50
    logo_length = 25
    
    x, y, t = list(map(int, s.split()))
    # 求总长度
    x+=t
    y+=t
    # 一来一回为一个周期，两倍的长度，注意去掉logo长度
    interval_x = 2*(screen_width-logo_width)
    interval_y = 2*(screen_length-logo_length)
    
    x %= interval_x
    y %= interval_y
    
    # 超过了一半，要反向
    if x>(screen_width-logo_width):
        x = interval_x-x
    if y>(screen_length-logo_length):
        y = interval_y-y
    return '{} {}'.format(x, y)

# 过程模拟
def solve_method2(s):
    W, L = 800, 600
    w, l = 50, 25
    W, L = W-w, L-l # 750, 575 只需要计算左上顶点

    x, y, t = list(map(int, s.split()))
    d = [1, 1]
    while t:
        if (x==0 and d[0]==-1) or (x==W and d[0]==1):
            d[0]=-d[0]
        if (y==0 and d[1]==-1) or ( y==L and d[1]==1):
            d[1]=-d[1]
        x+=d[0]
        y+=d[1]
        t-=1
    return '{} {}'.format(x, y)

if __name__ == '__main__':
    assert solve_method1("0 0 10") == '10 10'
    assert solve_method1("500 570 10") == '510 570'
    assert solve_method2("0 0 10") == '10 10'
    assert solve_method2("500 570 10") == '510 570'
```



