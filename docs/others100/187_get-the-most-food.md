# 187 获取最多食物、获取食物游戏

## 题目描述

主办方设计了一个获取食物的游戏。

游戏的地图由`N`个方格组成，每个方格上至多2个传送门，通过传送门可将参与者传送至指定的其它方格。同时，每个方格上标注了三个数字：
1. 第一个数字`id`：代表方格的编号，从0到`N-1`，每个方格各不相同。
2. 第二个数字`parent-id`：代表从编号为`parent-id`的方格可以通过传送门传送到当前方格（-1则表示没有任何方格可以通过传送门传送到此方格，这样的方格在地图中有且仅有一个）。
3. 第三个数字`value`：取值在`[100，100]`的整数值，正整数代表参与者得到相应取值单位的食物，负整数代表失去相应数值单位的食物（参与者可能存在临时持有食物为负数的情况），0则代表无变化。

此外，在地图设计时，保证了参与者不可能到达相同的方格两次，并且至少有一个方格的`value`是正整数。

游戏开始后，参与者任意选择一个方格作为出发点，当遇到下列情况之一退出游戏：

- 参与者当前所处的方格无传送门。
- 参与者在任意方格上主动宣布退出游戏。

请计算参与者退出游戏后，最多可以获得多少单位的食物。

## 输入描述

第一行输入一个数字`N`，表示方格的个数。

第2行至第`N+1`行，第一个数字是`id`，第二个数字是`parent-id`，第三个数字是`value`。

## 输出描述

获取食物的数量。

## 示例描述

### 示例一

**输入：**

```text
7
0 1 8
1 -1 -2
2 1 9
4 0 -2
5 4 3
3 0 -3
6 2 -3
```

**输出：**

```text
9
```

**说明：**

有两种方式：
- 参与者从方格0出发，通过传送门到达方格4，再通过传送门到达方格5。一共获得8+(-2)+3=9个单位食物，得到食物最多
- 参与者在游戏开始时处于方格2，直接主动宣布退出游戏，也可以获得9个单位食物。

### 示例二

**输入：**

```text
3
0 -1 3
1 0 1
2 0 2
```

**输出：**

```text
5
```

**说明：**

参与者从方格0出发，通过传送门到达方格2，一共可以获得3+2=5个单位食物，此时得到食物最多。

## 解题思路

这是一道经典的二叉树路径问题，可以使用深度优先搜索(DFS)来解决。我们可以从根节点开始，递归地计算每个节点的最大路径和，然后取其中的最大值作为答案。在递归过程中，可以使用一个哈希表来记录已经计算过的节点的最大路径和，避免重复计算。

1.通过一个for循环，将节点的信息以 `[pid, val]` 的形式存储在 `nodes` 字典中，键为 `id`。

2.定义dfs函数，假如节点的父节点为-1，说明是根节点，如果不是，那么递归调用dfs来找出父节点的最大路径值，并与当前节点的值相加，与当前节点值相比，取max

3.定义max_val为负无穷，然后通过for循环来找出最大的最大路径值



## 解题代码

```python
n = int(input())
nodes = {}
for i in range(n):
    id, pid, val = map(int, input().split(" "))
    if id < 0 or id >= n or pid < -1 or pid >=n:
        continue
    nodes[id] = [pid, val]
dp = {}

def dfs(i):
    if i not in dp:
        if nodes[i][0] == -1:
            dp[i] = nodes[i][1]
        else:
            dp[i] = max(nodes[i][1], nodes[i][1] + dfs(nodes[i][0]))
    return dp[i]

max_val = -float("inf")
for i in reversed(range(n)):
    if i not in nodes:
        continue
    max_val = max(max_val, dfs(i))

print(max_val)
```

