#  107-整数编码

## 题目描述

实现一个整数编码方法，使得待编码的数字越小，编码后所占用的字节数越小编码规则如下

1. 编码时 7 位一组，每个字节的低 7 位用于存储待编码数字的补码
2. 字节的最高位表示后续是否还有字节，置 1表示后面还有更多的字节，置0  表示当前字节为最后一个字节
3. 采用小端序编码，低位和低字节放在低地址上
4. 编码结果按 16进制数的字符格式进行输出，小写字母需要转化为大写字母

## 输入描述

输入的为一个字符串表示的非负整数

## 输出描述

输出一个字符串表示整数编码的 16 进制码流



## 示例描述

### 示例一

**输入：**

```text
0
```

**输出：**

```text
00
```

**说明：**  

输出的 16 进制字符不足两位的前面补零

### 示例二

**输入：**

```text
100
```

**输出：**

```text
64
```

**说明：**  

100 的二进制表示为 0110 0100 只需一个字节进行编码字节的最高位 0，剩余7 位存储数字 100 的低 7 位(1100100)所以编码后的输出为 64

### 示例三

**输入：**

```text
1000
```

**输出：**

```text
E807
```

**说明：**  
1000 的二进制表示为 0011 1110 1000 至少需要两个字节进行编码。
第一个字节最高位是 1 剩余 7 位存储数字 1000 的低 7 位(1101000)
所以第一个字节的二进制位(1110 1000)即 E8
第二个字节最高位置 0 剩余的 7 位存储数字 1000 的第二个低 7 位(0000111)
所以第一个字节的二进制为(0000 0111)即 07
采用小端序编码 所以低字节 E8 输出在前面
高字节 07 输出在后面。

**备注**
代编码数字取值范围为 `[ 0，1 << 64 - 1 ]`

## 解题思路

该题编写思路是实现一个十进制数转换成二进制后，分段转换为十六进制的过程。

1. 利用内置函数 bin()将十进制数转换为二进制字符串，利用切片操作[2:]去掉字符串前面的 0b.
2. 遍历二进制字符串，每 7 位分为一段
3. 如果当前段的长度不足 7 位，则在前面补 0，使得每一段长度都为 7 位
4. 将当前段的第一位置为 0 或 1，代表最高位的符号位
5. 利用内置函数 int()和 hex()将当前段的二进制字符电转换为十六进制整数，再利用 upper ()函数将其转为大写字母，最后利用zfill()函数使得十六进制数的位数始终为 2 位
6. 将所有十六进制数 拼接起来，得到最终的十六进制字符串。
7. 将最终的十六进制字符串输出到控制台。



## 解题代码

```python
def solve_method(num):
	binary = bin(num)[2:]
	length = len(binary)
	builder = ""
	for i in range(length, 0, -7):
		start = max(i - 7, 0)
		bin_ = binary[start:i]
		if len(bin_) < 7:
			head = "0" * (7 - len(bin_))
			bin_= head + bin_
		bin_ = "0" + bin_ if i - 7 <= 0 else "1" + bin_
		hex_  = hex(int(bin_,2)).upper()[2:].zfill(2)
		builder += hex_

	#print(builder)
	return builder



if __name__ == "__main__":
	assert solve_method(0) == '00' 
	assert solve_method(100) == '64' 
	assert solve_method(1000) == 'E807' 
```