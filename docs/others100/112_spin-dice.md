#  112-旋转骰子

## 题目描述

骰子是一个正方体，每个面有一个数字，初始为左 1，右 2，前 3，后4，上5，下 6,用 123456 表示这个状态，放置在平面上，

- 可以向左翻转 (用L表示向左翻转 1 次) ;
- 可以向右翻转 (用 R 表示向右翻转 1 次) 
- 可以向前翻转 (用 F 表示向前翻转 1 次) ;
- 可以向后翻转 (用 B 表示向后翻转 1 次) ;
- 可以逆时针翻转 (用 A表示向逆时针翻转 1 次);
- 可以向顺时针翻转 (用 C 表示向顺时针翻转 1 次);

现从 123456 这个初始状态开始，根据输入的动作序列 计算最终的状态

## 输入描述

一列字母序列，表示骰子旋转操作。

## 输出描述

一串数字序列，依照顺序表示骰子左面 右面 前面 后面 上面 下面 的数字。

## 示例描述

### 示例一

**输入：**

```
LR
```

**输出：**

```
123456
```

### 示例二

**输入：**

```
FCR
```

**输出：**

```
342156
```

## 解题思路

1. 建立一个`roll_switch`字典，记录不同操作应该交换数字序列的位置。
2. 遍历字母序列 ，交换`res`序列的位置。
3. 返回结果。

## 解题代码

```python
def solve_method(line):
	res = ['1', '2', '3', '4', '5', '6']
	roll_switch={
	 	"L":lambda:roll(res,0, 2, 4, 6),
	 	"R":lambda:roll(res,4, 6, 0, 2),
	 	"F":lambda:roll(res,2, 4, 4, 6),
	 	"B":lambda:roll(res,4, 6, 2, 4),
	 	"A":lambda:roll(res,2, 4, 0, 2), 
	 	"C":lambda:roll(res,0, 2, 2, 4)}
	for c in line:
		roll_switch[c]()

	
	return "".join(res)

def roll(res,s1, e1 , s2, e2):
	res[s1:e1],res[s2:e2] = res[s2:e2],res[s1:e1][::-1]
	return res


if __name__ == "__main__":
	assert solve_method("LR") == "123456"
	assert solve_method("FCR") == "342156"
```

## 代码运行结果

```
LR
123456
```

