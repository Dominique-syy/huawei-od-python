# 064-压缩报文还原

## 题目描述

为了提升数据传输的效率，会对传输的报文进行压缩处理。输入一个压缩后的报文，请返回它解压后的原始报文。
压缩规则: n[str]， 表示方括号内部的str正好重复n次。
注意n为正整数 (0 < n <= 100)，str只包含小写英文字母，不考虑异常情况。
注：
1) 原始报文长度不会超过1000，不考虑异常的情况

## 输入描述
输入压缩后的报文：

1. 不考虑无效的输入，报文没有额外的空格，方括号总是符合格式要求的；

2. 原始报文不包含数字，所有的数字只表示重复的次数n，例如不会出现像5b或3[81的输入；


## 输出描述

解压后的原始报文

## 示例描述

### 示例一

**输入：**
```
3[k]2[mn]
```

**输出：**
```
kkkmnmn
```

### 示例二

**输入：**

```
3[m2[c]]
```

**输出：**

```
mccmccmcc
```

## 解题思路

使用堆栈解决

可能的输入包括：'['，']'，字母或数字，逐一讨论每种情况。
遍历字符串的每个元素，如果遇到一个数字，通过检查isdigit()条件来处理它。
当遇到一个字符时，将它添加到当前的字符串中。
当遇到 '\[' 时，意味着这是一个新子字符串的开头，这意味着先前的子字符串（如果存在）已经被遍历和处理过。
因此，我们将当前的字符串和数字入栈，并将当前字符串重置为空字符串，数字重置为0，
以便在进一步处理中使用，
最后，当遇到闭合括号 ']' 时，它意味着已经到达了子字符串的结束位置，
在堆栈中，会找到一个顶部的数字，它会被弹出，然后是前面的字符串，将其与当前字符串相加，
然后将所有内容在计算后存储在当前字符串中。如果's'已经结束，
计算得到的当前字符串将作为答案返回，否则当遇到开放括号时，它将再次被附加到堆栈中。
并且上述过程将根据条件重复进行。

```python
def decodeString(s):
    prev, curr = '', ''
    stack = []
    num = 0
    for i in range(len(s)):
        if s[i].isdigit():
            num = num * 10 + int(s[i])
        elif s[i] == '[':
            stack.append(curr)
            stack.append(num)
            curr = ''
            num = 0
        elif s[i] == ']':
            curr_num = stack.pop()
            prev = stack.pop()
            curr = prev + curr_num * curr
        else:
            curr += s[i]

    return curr


if __name__ == '__main__':
    compressed_string = input().strip()
    res = decodeString(compressed_string)
    print(res)

```

