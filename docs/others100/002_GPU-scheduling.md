# 002-GPU调度

## 题目描述
为了充分发挥 GPU 算力，需要尽可能多的将任务交给 GPU 执行，
现在有一个任务数组，数组元素表示在这1s内新增的任务个数，
且每秒都有新增任务，假设 GPU 最多一次执行 n 个任务，
一次执行耗时 1s,在保证 GPU 不空闲的情况下，最少需要多长时间执行完成。
## 输入描述
第一个参数为 GPU 最多执行的任务个数
取值范围 1~10000
第二个参数为任务数组的长度
取值范围 1~10000
第三个参数为任务数组
数字范围 1~10000
## 输出描述
执行完所有任务需要多少秒
## 示例描述
### 示例一
**输入：**
```
3
5
1 2 3 4 5
```
**输出：**
```
6
```
**说明：**  
* 
* 一次最多执行 3 个任务
* 最少耗时 6s
## 解题思路
该算法首先读取输入，然后遍历所有的作业，计算完成这些作业所需的时间。作业的完成时间为作业的长度加上可能需要的等待时间。
在任何给定的时间，如果当前任务的长度与已累积的等待时间之和大于处理器的容量，则必须等待一段时间，使更多的作业能够进入队列。
将当前任务长度和已经积累的等待时间相加并检查其是否超出处理器容量，如果超出则等待一段时间（即将积累的等待时间加上当前作业
的长度减去处理器容量)，否则不需要等待时间。在完成所有作业之后，可能仍然需要等待一段时间，直到所有剩余的作业都完成：

### 核心知识点

* 循环结构
* 数组

## 解题代码

```python
def solve_method(n,jobs):
    # time总时间
    # more超过时间
    time,more = 0, 0
    for i in jobs:
        # 当前工作加上之前的超时时间会超出时间段长度
        if i + more > n:
            # 超出的部分被保存到more中
            more =i+more -n
        else:
            # 当前工作没有超过时间段长度
            more = 0
        # 经历的秒数
        time +=1
    # 下面继续进行循环执行任务
    while more > 0:
        more -n
        time +=1
    print(time)

if __name__ == '__main__':
    n, length = map(int,input().split())
    jobs = list(map(int,input().split()))
    solve_method(n,jobs)
```

