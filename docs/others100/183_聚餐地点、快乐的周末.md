# 183聚餐地点、快乐的周末

## 题目描述

小华和小为是很好的朋友，他们约定周末一起吃饭，通过手机交流，他们在地图上选择了很多聚餐地点(由于自然地形等原因，部分聚餐地点不可达)，求小华和小为都能达到的聚餐地点有多少个。

## 输入描述

第一行输入m和n ， m表示地图长度，n表示地图宽度

第二行开始具体输入地图信息，地图信息包括

0为通畅的道路

1为障碍物（且仅1为障碍物)

2为小华或小为，地图中必定有且仅有两个（非障碍物)

3为被选中的聚餐地点（非障碍物)

## 输出描述

可以两方都到达的聚餐地点的数量，行末无空格

## 示例描述

### 示例一

**输入：**

```shell
4 4 
2 1 0 3
0 1 2 1
0 3 0 0
0 0 0 0
```

**输出：**

```shell
2
```

**说明：**  

地图长宽为m和n , 4 <= m <= 100, 4 <= n <= 100聚餐的地点数量为k，则1< k <= 100

## 解题思路

bfs广度优先搜索函数的定义

1.定义队列queue，集合visited，用于记录已经访问过的点

2.进入while循环，使用popleft取出队首的点坐标(r, c)，假如(r, c)等于目标点坐标end_spot，则说明找到了一条路径，返回True

3.使用for循环遍历4个方向的偏移量，并根据偏移量计算新的点坐标

4.进行边界判断，如果新的点超出迷宫范围或者是障碍物，则跳过该点；如果新点不在visited中，则将其加入队列和visited

5.如果循环结束仍然没有找到目标点，则返回False

bfs广度优先搜索函数的调用

1.使用一个嵌套的循环遍历所有的目标点，对于每个目标点，检查是否存在一条从任意起始点到该目标点的路径

2.如果所有的目标点都存在路径，则将计数器count加1，输出最终的count



## 解题代码

```python
from collections import deque

def bfs(row,col):
    queue = deque([(row,col)])
    visited = set([(row,col)])
    while queue:
        r,c=queue.popleft()

        if (r,c)==end_spot:
            return True
        for dr,dc in [(-1,0),(1,0),(0,-1),(0,1)]:
            nr,nc = r+dr,c+dc
            if not (0 <= nr <m and 0 <= nc <n) or map_[nr][nc] == "1":
                continue
            if (nr,nc) not in visited:
                queue.append((nr,nc))
                visited.add((nr,nc))

    return False

n,m = map(int,input().split())
map_ = [input().split() for _ in range(m)]

start_spots = []
end_spots = []

for i in range(m):
    for j in range(n):
        if map_[i][j] == "2":
            start_spots.append((i,j))
        elif map_[i][j]== "3":
            end_spots.append((i,j))
count = 0

for end_spot in end_spots:
    if all(bfs(start_spot[0],start_spot[1]) for start_spot in start_spots):
        count +=1

print(count)
```

