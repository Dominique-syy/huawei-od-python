# 196跳格子（1）

## 题目描述

地上共有N个格子，你需要跳完地上所有的格子，但是格子间是有强依赖关系的，跳完前一个格子后，后续的格子才会被开启，格子间的依赖关系由多组steps数组给出，
steps[0]表示前一个格子, steps[1]表示steps[0]可以开启的格子:
比如[0,1]表示从跳完第0个格子以后第1个格子就开启了，
比如[2,1]，[2,3]表示跳完第2个格子后第1个格子和第3个格子就被开启了
请你计算是否能由给出的steps数组跳完所有的格子，
如果可以输出yes，否则输出no
说明:

1. 你可以从一个格子跳到任意一个开启的格子
2. 没有前置依赖条件的格子默认就是开启的
3. 如果总数是 N，则所有的格子编号为[ 0,1,2,3….N-1]连续的数组

1 <= N < 500

steps[ i ].length = 2

0 <= step[ i ][ 0 ]，step[ i ][1] < N

## 输入描述

输入一个整数N表示总共有多少个格子，接着输入多组二维数组steps表示所有格子之间的依赖关系

## 输出描述

如果能按照steps 给定的依赖顺序跳完所有的格子输出yes

否则输出no

## 示例描述

### 示例一

**输入：**

```shell
3
0 1
0 2
```

**输出：**

```shell
yes
```

**说明：**

1. 总共有三个格子[0,1,2]，跳完0个格子后第1个格子就开启了，
2. 跳到第0个格子后第2个格子也被开启了，
3. 按照0->1->2或者0->2->1的顺序都可以跳完所有的格子

## 解题思路

本题的目标是实现了一个跳格子游戏的逻辑，核心思路是利用栈和字典，按照行列分别存储已经走过的格子，然后遍历每一个空白格子，判断它是否可以到达边界，最后判断是否所有的空白格子都不能到达边界，从而判断游戏是否可以成功。

## 解题代码

```python
from typing import List


def skip_grid(n: int，grids : List[List[int]])-> bool:
    x =[None] * n
    map = {}
    for i in range (len(grids)) :
        a = grids[i]
        if a[0] not in map:
            map[a[0]] =[]
        map[a[0] ] . append(a[1])
        x[a[1]] = a[0]
    stack =[]
    for i in range(n):
        if x[i] is None:
            stack. append(i)
    if not stack:
        return False
    while stack:
        index = stack. pop()
        x[index] = -1
        if index not in map:
            continue
            for item in map[index]:
                if x[item] != -1:
                    stack. append(item)
    return all(val -= -1 for val in x)  


if __name__ == '__main__':
    n = 2
    grids =[[1,0]，[0，1]]
    r = skip_grid(n, grids)
    print( "yes" if r else "no")
```

