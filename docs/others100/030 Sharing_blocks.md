# 030 分积木

## 题目描述

`solo`和 `koko`是两兄弟
妈妈给了他们一大堆积木
每块积木上都有自己的重量
现在他们想要将这些积木分为两堆
哥哥 `solo` 负责分配
弟弟 `koko` 要求两个人获得的积木总重量相等
(根据 `koko` 的逻辑),个数可以不同,不然就会哭
但 `koko` 只会先将两个数转成二进制在进行加法
而且总会忘记进位(每个进位都会忘记)
如当 `25(11101)+1(1011)` 时,
`koko` 得到的计算结果是 `18(10):11001+01011=10010`
`solo` 想要尽可能让自己得到的积木总重量最大,目不让 `koko` 哭

## 输入描述

第一行是一个整数`N (2 <= N <= 100)`
表示有多少块积木
第二行为空格分开的 N 个整数 `ci (1 <= ci <= 10^6)`
表示第 `i` 块积木的重量

## 输出描述

让 `koko` 不哭输入 `solo`所能获得积木的最大总重量
否则输出`“No"`

## 示例描述

### 示例一

**输入：**

```Plain Text
3
3 5 6
```

**输出：**

```Plain Text
11
```

**说明：**
备注:如果能让 `koko` 不哭,输出 `solo` 所能获得的积木的总重量,否则输出 -1
该样例输出为`11`解释:
`solo` 能获得重量为 `5` 和 `6` 的两块积木
`5` 转成二进制为 `101`
`6` 转成二进制为 `110`
按照 `koko` 的计算方法(忘记进位)结果为 `11`(二进制)
`koko` 获得重量为 `3` 的积木转成二进制为 `11`
`solo` 和 `koko` 得到的积木的重量都是 `11`(二进制)
因此 `solo` 可以获得的积木的总重量是 `5+6=11` (十进制)

## 解题思路

**基本思路：** 因为 `koko`  是将数值转换为二进制进行加法计算且不算进位，所以等同于二进制的异或运算，因此

1. 用`for`循环对每个数进行异或运算

2. 如果`count=0`则满足`koko`的需求，然后用`sum(n)-min(n)`算出 `solo` 获的苹果最大重量

3. 如果`count ≠ 0` 时，则返回`-1`

## 解题代码

```Python
def solve(num):
    if len(n) != nums:
        return False
    count = 0
    # 进行异或运算
    for i in n:
        count = count^i
    if count == 0:
        return sum(n) - min(n)
    else:
        return -1
if __name__ == '__main__':
    nums = int(input()) # 输入积木的数量
    n = [int(x) for x in input().split()] # 输入每个积木的重量 
    result = solve(n)
    print(result)
```

