# 029 出错的或电路

## 题目描述

某生产门电路只的厂商发现某一批次的或门电路不稳定，具体现象为计算两个二进制数的或操作时，第一个二进制数中某两个比特位会出现交换，交换的比特位置是随机的，但只交换这两个位，其他位不变。
很明显，这个交换可能会影响最终的或结果，也可能不会有影响。
为了评估影响和定位出错的根因，工程师需要研究在各种交换的可能下，最终的或结果发生改变的情况有多少种。

## 输入描述

第一行有一个正整数 N; 其中 1≤N≤1000000.
第二行有一个长为 N 的二进制数，表示与电路的第一个输入数，即会发生比特交换的输入数。
第三行有一个长为 N 的二进制数，表示与电路的第二个输入数。注意第二个输入数不会发生比特交换。

## 输出描述

输出只有一个整数，表示会影响或结果的交换方案个数。

## 示例描述

### 示例一

**输入：**

```Plain Text
3
010
110
```

**输出：**

```Plain Text
1
```

**说明：**
原本 010 和 110 的或结果是 110，但第一个输入数可能会发生如下三种交换

1.交换第 1 个比特和第 2 个比特，第一个输入数变为 100，计算结果为 110，计算结果不变

2. 交换第 1 个比特和第3 个比特，第一个输入数变为 010，计算结果为 110，计算结果不变  

3.交换第 2 个比特和第3 个比特，第一个输入数变为 001，计算结果为 111，计算结果改变
故只有一种交换会改变计算结果。

### 示例二

**输入：**

```Plain Text
6
011011
110110
```

**输出：**

```Plain Text
4
```

**说明：**
原本 011011 和 110110 的或结果是 111111，但第一个输入数发生如下比特交换会影响最终计算结果

1. 交换第 1 个比特和第 3 个比特，第一个输入数变为 110011，计算结果变为 110111
2. 交换第 1 个比特和第 6 个比特，第一个输入数变为 111010，计算结果变为 111110
3. 交换第 3 个比特和第 4 个比特，第一个输入数变为 010111，计算结果变为 110111
4. 交换第 4 个比特和第 6 个比特，第一个输入数变为 011110，计算结果变为 111110
其他的交换都不会影响计算结果，故输出 4

## 解题思路

**基本思路：** 直接比较两个二进制数的相应位。当第一个二进制数与第二个二进制数的对应位不相等时，计算交换后的结果必然存在不一样的情况，因此计数器`count+=1`

## 解题代码

```Python
def solve(n, num1, num2):
    count = 0
    for i in range(n):
        # 比较两个二进制数的相应位
        if num1[i] != num2[i]:
            count += 1
    return count

if __name__ == '__main__':
    n = int(input()) # 输入n，表示二进制数的位数
    num1 = input() # 输入长度为n的二进制数
    num2 = input() # 输入长度为n的二进制数

    result = solve(n, num1, num2)
    print(result)
```



