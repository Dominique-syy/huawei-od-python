# 146 水仙花数

## 题目描述

所谓的水仙花数（其实叫**自幂数**更准确）是指一个` n` 位的正整数，满足其`各位数字的 n 次方的和`等于该数本身，一例如 `153 = 1^3 + 5^3 + 3^3`，153 是一个三位数。



## 输入描述

第一行输入一个`整数N`，表示 N 位的正整数 N。

第二行输入一个正整数 `M`，表示需要返回第`M`个水仙花数。

- 注意：如果输入的N不在3<=N<=7，视为输入不合法，返回-1。



## 输出描述

返回长度是`N`的第`M`个水仙花数，个数从 `0` 开始编号。
若`M`大于水仙花数的个数，返回最后一个水仙花数和 `M`的乘积。
若输入不合法返回`—1`。



## 示例描述

### 示例一

**输入：**

```text
3
0
```

**输出：**

```text
153
```

**说明：**  

153 是第一个水仙花数




### 示例二

**输入：**

```text
9
1
```

**输出：**

```text
-1
```

**说明：**  

n 不满足条件（在3到7之间），无效输入返回-1。




## 解题思路

**基本思路：** 

- 首先检查 n 是否满足条件，即 n 必须在 3 到 7 之间。如果不满足条件，则输出 -1。
- 对于 n 在 3 到 7 之间的情况，找到所有 n 位数，并检查它们是否是水仙花数（即每一位上的数字的 n 次幂之和等于这个数本身）。如果找到了 m+1 个水仙花数，则输出第 m+1 个水仙花数并退出。
- 如果在整个 n 位数中找不到 m+1 个水仙花数，则输出 m 乘以最后一个找到的水仙花数。



**注：**

常见自幂数包括以下：

> [自幂数_百度百科 (baidu.com)](https://baike.baidu.com/item/自幂数?fromModule=lemma_inlink)
>
> 独身数（1位）共有9个: 1，2，3，4，5，6，7，8，9；
>
> 水仙花数（3位）共有4个：153，370，371，407；
>
> 四叶玫瑰数（4位）共有3个：1634，8208，9474；
>
> 五角星数（5位）共有3个：54748，92727，93084；
>
> 六合数（6位）只有1个：548834；
>
> 北斗七星数（7位）共有4个：1741725，4210818，9800817，9926315；
>
> 八仙数（8位）共有3个：24678050，24678051，88593477





## 解题代码

```python
from typing import List


def solve_method(N: int, M: int) -> int:
    # 1. 检查输入是否有效
    if not (3 <= N <= 7):
        return -1

    # 2. 空间换时间: 制作一个数字 0 到 9 的 n次方的"哈希表"(这里用二维列表)，避免后续重复计算一个数字的 n次方
    # digit_power[i][j] 数字i 的 j次幂的值
    digit_power = [[0] * (N + 1) for _ in range(10)]
    for i in range(1, 10):
        digit_power[i][0] = 1
        for j in range(1, N + 1):
            digit_power[i][j] = digit_power[i][j - 1] * i

    # 3.通过循环查找自幂数,注意使用 digit_power 避免重复计算
    nums: List[int] = []
    start, end = 10 ** (N - 1), 10 ** N

    for num in range(start, end):
        sum = 0			# 保存每个数字的幂次之和
        num_copy = num 	# 用来获取数字的每一位数
        while num_copy != 0:
            sum += digit_power[(num_copy % 10)][N]
            num_copy //= 10

        if sum == num:
            nums.append(num)

        # 提前返回: 如果要查找的 M 已经找到,提前返回(注意M类似索引,从0开始，而自幂数列表的长度比索引多1)
        if len(nums) == M + 1:
            return nums[-1]

    # 4. 若`M`大于水仙花数的个数，返回最后一个水仙花数和 `M`的乘积。
    return nums[M] if M < len(nums) else M * nums[-1]
```



## 总结与分析

1. 在本题中，限制了`N`的范围是[3,7]，这使得我们可以直接编写复杂度较高的算法（直接用循环去判断每个数是不是自幂数），时间开销可以忍受。但如果要查找N=8,9,10,...时的自幂数，显然这样的算法在时间上有些低效了。
2. 在我们的解法中，采用了两个小技巧在时间上进行优化：
   - 通过时间换空间，只计算一次 **个位数1-9 的n次幂的值**，我们**避免了冗余的计算**，提高了代码的**复用**率。
   - 在循环中引入判断，提前返回目标值
3. 实际上，当然还有更多优化手段，比如：

> [寻找自幂数的优化算法 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/570576659) 
>
> 我们不去一个一个数字地做判断，而是分析【数字中选了0个9、选了1个9、选了2个9...、全选了9，选了0个8、选了1个8、...】，这样就建立了一个决策树。如此一来，便可运用**深度优先搜索算法**进行编写。
>
> 可以在树的每一个结点记录的是 **当前统计数字、当前和、剩余位数** ；搜索方式就是在剩余位数基础上选 `i` 个当前数字，更新当前和。
>
> 不必继续往下搜索的情况有以下：
>
> 1. 已对所有数字进行了搜索（当前统计数字小于0）
> 2. 剩余可选位数不足
>
> 关键的是**剪枝**过程。在搜索过程中，如果我们在这个分支上已经不可能找到目标，就可以回溯到上个节点，分析下一分支。比如分析3位水仙花数里，枚举到了两个9的情况，9^3*2=729\*2>1000，可以跳过这种情况，分析1个9的情况。