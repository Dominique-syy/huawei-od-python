# 187获取最多食物

## 题目描述

主办方设计了一个获取食物的游戏。
游戏的地图由N个方格组成，每个方格上至多2个传送门，通过传送门可将参与者传送至指定的其它方格。同时，每个方格上标注了三个数字:
1.第一个数字id:代表方格的编号，从0到N ―1，每个方格各不相同;
2.第二个数字parent - id:代表从编号为parent - id的方格可以通过传送门传送到当前方格(-1则表示没有任何方格可以通过传送门传送到此方格，这样的方格在地图中有且仅有一个);
3.第三个数字value:取值在[100，100]的整数值，正整数代表参与者得到相应取值单位的食物，负整数代表失去相应数值单位的食物(参与者可能存在临时持有食物为负数的情况)，0则代表无变化。
此外，地图设计时保证了参与者不可能到达相同的方格两次，并且至少有一个方格的value是正整数。游戏开始后，参与者任意选择一个方格作为出发点，当遇到下列情况之一退出游戏:
-参与者当前所处的方格无传送门;
-参与者在任意方格上主动宣布退出游戏。
请计算参与者退出游戏后，最多可以获得多少单位的食物。

## 输入描述

输入N+1行
第一行数字是N

第2行至第N行，第一个数字是id，第二个数字是parent - id，第三个数字是value

## 输出描述

获取食物的数量，一个数字

## 示例描述

### 示例一

**输入：**

```shell
7
0 1 8
1 -1 -2
2 1 9
4 0 -2
5 4 3
3 0 -3
6 2 -3
```

**输出：**

```shell
9
```

**说明：**参与者从方格0出发，通过传送门到达方格4，再通过传送门到达方格5。一共获得8＋(-2)+3=9个单位食物，得到食物最多或者参与者在游戏开始时处于方格2，直接主动宣布退出游戏，也可以获得9个单位食物。

## 解题思路

这是一道经典的二叉树路径问题，可以使用深度优先搜索(DFS)来解决。我们可以从根节点开始，递归地计算每个节点的最大路径和，然后取其中的最大值作为答案。在递归过程中，可以使用一个哈希表来记录已经计算过的节点的最大路径和，避免重复计算。

1.通过一个for循环，将节点的信息以 `[pid, val]` 的形式存储在 `nodes` 字典中，键为 `id`。

2.定义dfs函数，假如节点的父节点为-1，说明是根节点，如果不是，那么递归调用dfs来找出父节点的最大路径值，并与当前节点的值相加，与当前节点值相比，取max

3.定义max_val为负无穷，然后通过for循环来找出最大的最大路径值



## 解题代码

```python
n = int(input())
nodes = {}
for i in range(n):
    id, pid, val = map(int, input().split(" "))
    if id < 0 or id >= n or pid < -1 or pid >=n:
        continue
    nodes[id] = [pid, val]
dp = {}

def dfs(i):
    if i not in dp:
        if nodes[i][0] == -1:
            dp[i] = nodes[i][1]
        else:
            dp[i] = max(nodes[i][1], nodes[i][1] + dfs(nodes[i][0]))
    return dp[i]

max_val = -float("inf")
for i in reversed(range(n)):
    if i not in nodes:
        continue
    max_val = max(max_val, dfs(i))

print(max_val)
```

