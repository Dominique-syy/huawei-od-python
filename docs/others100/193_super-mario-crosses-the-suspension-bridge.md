# 193 超级玛丽过吊桥

## 题目描述

超级玛丽好不容易来到新的一关，有一个长长的吊桥，吊桥的尽头是下水管道，其中随机的木板存在缺失，一旦踩到就会死亡，死亡后如果还有剩余的生命将在原地复活且不受木板缺失影响，但会消耗一次生命，如果跨过了管道，将跌入悬崖，通关失败。

超级玛丽从起点`S`开始，可以走到下一个木板（计1），也可以跳着跨过一个块（计2）或两个木板（计3），最终必须刚好走到终点`E`。

现在给定超级玛丽当前的生命数`M`，吊桥的长度`N`，缺失的木板数`K`，以及随机缺失的木板编号数组`L`，请帮忙计算一下，超级玛丽有多少种方法可以通过此关。

## 输入描述

第一行是`M N K`，分别表示：
- `M`表示超级玛丽当前生命数，取值范围是1 <= M <= 5。
- `N`表示吊桥的长度，取值范围是1 <= N <= 32。
- `K`表示缺失木板数，取值范围是1 <= N <= 32。

第二行是`L`，表示缺失木板编号数组，长度及编号的内容不大于`N`的编号数组，其中1 <= L[i] <= N，由空格分隔的整数数组。

## 输出描述

输出通过此关的吊桥走法个数，如果不能通过此关，请输出0。

## 示例描述

### 示例一

**输入：**

```text
2 2 1
2
```

**输出：**

```text
4
```

**说明：**

2个生命，2个木板，缺失1个木板，其中第2个木板有缺失，一共有4种走法：

1. 直接走两个木板，到达终点。
2. 先走一步，然后再跨过一个木板，到达终点。
3. 先走一步，再走一步，死亡，之后复活，到达终点。
4. 先跨过一个木板，再走一步，死亡，之后复活，到达终点。

### 示例二

**输入：**

```text
1 3 2
1 3
```

**输出：**

```text
1
```

**说明：**

1个生命，3个木板，缺失2个木板，第1、3个木板有缺失，只有1种走法，其他都不能通关。

具体走法：跨过一个木板，走一步，再跨过一个木板，可以正好抵达终点。

### 示例三

**输入：**

```text
3 10 2
4 7
```

**输出：**

```text
5
```

## 解题思路

1. `def solve(M, N, K, trap):`: 定义一个函数 `solve`，接受四个参数：`M` 表示每次可以移动的最大步数，`N` 表示桥梁的长度，`K` 表示陷阱的数量，`trap` 是一个包含陷阱位置的列表。
2. 初始化 `bridge` 列表，长度为 `N + 2`，表示桥梁的状态，初始化时都为可通行状态（`True`）。
3. 遍历陷阱位置列表 `trap`，将对应的桥梁位置设置为不可通行状态（`False`）。
4. 初始化 `dp` 列表，是一个二维列表，表示状态转移表。`dp[i][j]` 表示在第 `i` 个位置，还剩余 `j` 步可移动的方案数。初始化时，起点位置 `dp[0][M]` 设置为1，表示从起点出发，剩余 `M` 步的方案数为1。
5. 使用两个嵌套循环遍历状态转移表 `dp`：
   - 在循环内部，首先计算 `k`，即下一步的位置。如果当前位置是陷阱，则下一步位置不变，否则加1。
   - 根据状态转移方程计算 `dp[i][j]`。当 `i` 小于等于2 时，分别考虑上一步、上两步的方案数。当 `i` 大于2 时，考虑上一步、上两步、上三步的方案数。
6. 计算最终结果，将 `dp[N + 1]` 列表中前 `len(dp[0]) - 1` 项的和，表示从终点出发的路径数量。
7. 返回结果。
8. 在 `if __name__ == "__main__":` 块中：
   - 从输入读取三个整数 `M`、`N` 和 `K`，表示每次移动的步数、桥梁长度和陷阱数量。
   - 从输入读取陷阱位置列表 `trap`。
   - 调用 `solve` 函数，计算并获得最终结果。
   - 输出结果。

## 解题代码

```python
def solve(M, N, K, trap):
    bridge = [True] * (N + 2)
    for i in range(K):
        bridge[trap[i]] = False

    dp = [[0] * (M + 2) for _ in range(N + 2)]
    dp[0][M] = 1

    for i in range(1, len(dp)):
        for j in range(1, len(dp[0]) - 1):
            k = j + 1 if not bridge[i] else j
            if i == 1:
                dp[i][j] = dp[i - 1][k]
            elif i == 2:
                dp[i][j] = dp[i - 1][k] + dp[i - 2][k]
            else:
                dp[i][j] = dp[i - 1][k] + dp[i - 2][k] + dp[i - 3][k]
    res = sum(dp[N + 1][: len(dp[0]) - 1])
    return res


if __name__ == "__main__":
    M,N,K = map(int, input().split())
    trap = list(map(int, input().split()))
    s = solve(M, N, K, trap)
    print(s)
```

