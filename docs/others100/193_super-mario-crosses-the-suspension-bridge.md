# 193 超级玛丽过吊桥

## 题目描述

超级玛丽好不容易来到新的一关，有一个长长的吊桥，吊桥的尽头是下水管道，其中随机的木板存在缺失，一旦踩到就会死亡，死亡后如果还有剩余的生命将在原地复活且不受木板缺失影响，但会消耗一次生命，如果跨过了管道，将跌入悬崖，通关失败。

超级玛丽从起点`S`开始，可以走到下一个木板（计1），也可以跳着跨过一个块（计2）或两个木板（计3），最终必须刚好走到终点`E`。

现在给定超级玛丽当前的生命数`M`，吊桥的长度`N`，缺失的木板数`K`，以及随机缺失的木板编号数组`L`，请帮忙计算一下，超级玛丽有多少种方法可以通过此关。

## 输入描述

第一行是`M N K`，分别表示：
- `M`表示超级玛丽当前生命数，取值范围是1 <= M <= 5。
- `N`表示吊桥的长度，取值范围是1 <= N <= 32。
- `K`表示缺失木板数，取值范围是1 <= K <= N。

第二行是`L`，表示缺失木板编号数组，长度及编号的内容不大于`N`的编号数组，其中1 <= L[i] <= N，由空格分隔的整数数组。

## 输出描述

输出通过此关的吊桥走法个数，如果不能通过此关，请输出0。

## 示例描述

### 示例一

**输入：**

```text
2 2 1
2
```

**输出：**

```text
4
```

**说明：**

2个生命，2个木板，缺失1个木板，其中第2个木板有缺失，一共有4种走法：

1. 直接跳过两个木板，到达终点。
2. 先走一步，然后再跳过一个木板，到达终点。
3. 先走一步，再走一步，掉进陷阱，死亡之后复活，再走一步，到达终点。
4. 先跳过一个木板，掉进陷阱，死亡之后复活，再走一步，到达终点。

### 示例二

**输入：**

```text
1 3 2
1 3
```

**输出：**

```text
1
```

**说明：**

1个生命，3个木板，缺失2个木板，第1、3个木板有缺失，只有1种走法，其他都不能通关。

具体走法：跳过一个木板，再跳过一个木板，可以正好抵达终点。

### 示例三

**输入：**

```text
3 10 2
4 7
```

**输出：**

```text
5
```

## 解题思路



## 解题代码

```python
def solve_method(M, N, K, L):
    """
    :param M: 超级玛丽当前的生命数
    :param N: 吊桥的长度
    :param K: 缺失木板数
    :param L: 缺失木板编号数组
    :return: 通过此关的吊桥走法个数
    """
    bridge = [True] * (N + 2)
    for i in L:
        bridge[i] = False

    # dp[i][j]表示达到位置i并剩余j条生命的方法数
    dp = [[0] * (M + 2) for _ in range(N + 2)]
    # 表示从起点出发，剩余M条生命的方案数为1
    dp[0][M] = 1

    for i in range(1, len(dp)):
        for j in range(1, len(dp[0]) - 1):
            k = j + 1 if not bridge[i] else j
            if i == 1:
                dp[i][j] = dp[i - 1][k]
            elif i == 2:
                dp[i][j] = dp[i - 1][k] + dp[i - 2][k]
            else:
                dp[i][j] = dp[i - 1][k] + dp[i - 2][k] + dp[i - 3][k]
    res = sum(dp[N + 1][: len(dp[0]) - 1])
    return res


if __name__ == "__main__":
    assert solve_method(2, 2, 1, [2]) == 4
    assert solve_method(1, 3, 2, [1, 3]) == 1
```

