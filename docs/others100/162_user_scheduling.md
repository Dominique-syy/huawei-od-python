# 162 - 环中最长子串

## 题目

在通信系统中有一个常见的问题是对用户进行不同策略的调度，会得到不同系统消耗的性能。假设由`N`个待串行用户，每个用户可以使用`A/B/C`三种不同的调度策略。不同的策略会消耗不同的系统资源，请你根据如下规则进行用户调度，并返回总的消耗资源数。

规则是:
相邻的用户不能使用相同的调度策略。



例如:
第一个用户使用`A`策略，则第二个用户只能使用`B`和`C`策略。
对单的用户而言，不同的调度策略对系统资源的消耗可以规划后抽象为数值，例如:某用户分别使用`A B C`策略的系统消耗，分别为`15 8 17`，每个用户依次选择当前所能选择的对系统资源消耗最少的策略,局部最优，如果有多个满足要求的策略，选最后一个。



## 输入

第一行表示用户个数N
接下来表示每—行表示一个用户分别使用三个策略的资源消耗`resA resB resC`



## 输出描述

最优策略组合下的总的系统消耗资源数



## 示例一

### 输入

```python
3
15 8 17
12 20 9
11 7 5
```

### 输出

```
24
```

### 说明

`1`号用户使用B策略

`2`号用户使用C策略

`3`号用户使用B策略

系统资源消耗`8+9+7`



## 解题思路

我们无法使用贪心的思想，由每一步选择最小值而保证最后得到最小值。 

我们只能使用动态规划去穷举所有可能性的结果，三个策略分别使用三个维度进行深入，表示当前选择A时的最小值为多少，那么推到公式为：上一步选择B和C中的较小值+此处A的值。

其余选择B和C策略时也同样的思路。

记得初始化，因为我们的公式是由上一步的结果推导而来，而第一步没有上一步。



## 解题代码

```python
def solve_method(n, cost):
    # 构建ABC三个维度的dp表，表示当前选取A或B或C时消耗的最小资源
    dp = [[0,0,0] for i in range(n)]
    # 初始化，因为dp状态转移依赖于前一项
    dp[0] = cost[0]

    for i in range(1, n):
        # 当前选取A时，上一步选取B和C的最小消耗资源
        dp[i][0] = min(dp[i-1][1], dp[i-1][2])+cost[i][0]
        # 当前选取B时，上一步选取A和C的最小消耗资源
        dp[i][1] = min(dp[i-1][0], dp[i-1][2])+cost[i][1]
        # 当前选取C时，上一步选取A和B的最小消耗资源
        dp[i][2] = min(dp[i-1][0], dp[i-1][1])+cost[i][2]
    # 最后一列累加的总和，选取最小值即可
    return min(dp[-1])

if __name__ == '__main__':
    assert solve_method(3, [[15, 8,17],[12, 20, 9],[11, 7, 5]]) == 24

```



