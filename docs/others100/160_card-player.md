# 160玩牌高手

## 题目描述

题目 给定一个长度为`N`的整数数组，表示一个选手在`N`轮内选择的牌面分数 

选手基于规则选牌，请计算所有轮结束后其可以获得的最高总分数。

 选择规则如下：

1.  在每轮里选手可以选择获取该轮牌面，则其总分数加上该轮牌面分数为其新的总分数 
2. 选手也可不选择本轮牌面，直接跳到下一轮，此时将当前总分数还原为`3`轮前的总分数，若当前轮次小于等于`3`，则总分数置 `0`
3. 选手初始总分数为`0`，且必须依次参加每轮

## 输入描述

第一行为一个小写逗号分隔的字符串

 表示`N`轮的牌面分数 

`1<=N<=20`分数值为整数 `[-100,100]` 

 不考虑格式问题 

## 输出描述

所有轮结束后 选手能获得的最高总分数

## 示例描述

### 示例一

**输入：**

```text
1,-5,-6,4,3,6,-2
```

**输出：**

```text
11
```

## 解题思路

使用动态规划的思想，创建一个长度为`n+1`的列表`dp`，`dp[i]`表示在第`i`轮结束后可以获得的最高总分数。根据题目要求，如果当前轮次小于等于`3`，则总分数置`0`；否则，选择获取该轮牌面分数，将当前总分数加上该轮牌面分数，并与跳过该轮后的总分数比较取较大值。最后返回`dp[n]`，即在所有轮结束后可以获得的最高总分数。

## 解题代码

```python
def calculate_max_score(scores):
    n = len(scores)
    dp = [0] * (n + 1)

    for i in range(1, n + 1):
        # 如果当前轮次小于等于3，则总分数置0
        if i <= 3:
            dp[i] = 0
        else:
            # 选择获取该轮牌面分数
            dp[i] = dp[i - 1] + scores[i - 1]
        # 跳过该轮，将当前总分数还原为三轮前的总分数
        dp[i] = max(dp[i], dp[i - 3])

    return dp[n]

# 读取输入
scores = list(map(int, input().split(",")))

# 调用函数计算最高总分数
max_score = calculate_max_score(scores)

# 输出结果
print(max_score)
```

