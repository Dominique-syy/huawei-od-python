# 160 玩牌高手

## 题目描述

给定一个长度为`N`的整数数组，表示一个选手在`N`轮内选择的牌面分数，选手基于规则选牌，请计算所有轮结束后，其可以获得的最高总分数。

选择规则如下：
1. 在每轮中，选手可以选择获取该轮牌面，则其总分数加上该轮牌面分数为其新的总分数。 
2. 选手也可不选择本轮牌面，直接跳到下一轮，此时将当前总分数还原为3轮前的总分数，若当前轮次小于等于3，则总分数置0。
3. 选手初始总分数为0，且必须依次参加每轮。

## 输入描述

第一行是一个小写逗号分隔的字符串，表示`N`轮的牌面分数，取值范围是1 <= N <= 20，分数值为整数，取值范围是`[-100,100]`。 

## 输出描述

所有轮结束后，选手能获得的最高总分数。

## 示例描述

### 示例一

**输入：**

```text
1,-5,-6,4,3,6,-2
```

**输出：**

```text
11
```

**说明：**

总共7轮牌面：
- 第1轮：选择该轮牌面总分数为1。
- 第2轮：不选择该轮牌面总分数还原为θ。
- 第3轮：不选择该轮牌面总分数还原为0。
- 第4轮：选择该轮牌面总分数为4。
- 第5轮：选择该轮牌面总分数为7。
- 第6轮：选择该轮牌面总分数为13。
- 第7轮：如果不选择该轮牌面，则总分数返回到三轮前的分数，即第四轮的总分数4，如果选择该轮牌面，总分数为11，所以选择该轮。
  
因此最高总分数为11。

## 解题思路

使用动态规划的思想，创建一个长度为`n+1`的列表`dp`，`dp[i]`表示在第`i`轮结束后可以获得的最高总分数。根据题目要求，如果当前轮次小于等于`3`，则总分数置`0`；否则，选择获取该轮牌面分数，将当前总分数加上该轮牌面分数，并与跳过该轮后的总分数比较取较大值。最后返回`dp[n]`，即在所有轮结束后可以获得的最高总分数。

## 解题代码

```python
def calculate_max_score(scores):
    n = len(scores)
    dp = [0] * (n + 1)

    for i in range(1, n + 1):
        # 如果当前轮次小于等于3，则总分数置0
        if i <= 3:
            dp[i] = 0
        else:
            # 选择获取该轮牌面分数
            dp[i] = dp[i - 1] + scores[i - 1]
        # 跳过该轮，将当前总分数还原为三轮前的总分数
        dp[i] = max(dp[i], dp[i - 3])

    return dp[n]

# 读取输入
scores = list(map(int, input().split(",")))

# 调用函数计算最高总分数
max_score = calculate_max_score(scores)

# 输出结果
print(max_score)
```

