# 245 最佳对手

## 题目描述
游戏里面，队伍通过匹配实力相近的对手进行对战。但是如果匹配的队伍实力相差太大，对于双方游戏体验都不会太好。 给定 n 个队伍的实力值，对其进行两两实力匹配，两支队伍实力差距在允许的最大差距 d 内，则可以匹配。

要求在匹配队伍最多的情况下，匹配出的各组实力差距的总和最小。

## 输入描述

第一行，n，d。队伍个数 n。允许的最大实力差距 d(2<=n<=50, 0<=d<=100)。

第二行，n 个队伍的实力值，空格分割（0<=各队伍实力值<=100）。

## 输出描述

匹配后，各组对战的实力差值的总和。若没有队伍可以匹配，则输出-1。

## 示例描述

### 示例一

**输入：**
```text
6 30
81 87 47 59 81 18
```

**输出：**
```text
57
```

**说明：**
18与47匹配，实力差距29；
59与81匹配，实力差距22；
81与87匹配，实力差距6。
总实力差距29+22+6=57。

### 示例二

**输入：**
```text
6 20
81 87 47 59 81 18
```

**输出：**
```text
12
```

**说明：**
47与59匹配，实力差距12；
81与81匹配，实力差距0。
总实力差距12+0=12。

### 示例三

**输入：**
```text
4 10
40 51 62 73
```

**输出：**
```text
-1
```

**说明：**
实力差距都在10以上，没有队伍可以匹配成功。

## 解题思路

**基本思路：**

看到最大最小等关键词，考虑动态规划。

题目有三点要求：
1. 实力差距在可允许范围内 --> 首先将队伍按实力排序
2. 匹配队伍尽可能多 --> 定义dp1[i]表示前i个队伍中，最多可以匹配的队伍数量
3. 实力差值总和最小 --> 定义dp2[i]表示前i个队伍中，最多匹配的队伍数量对应的实力差值总和

**代码思路：**
1. 将队伍按实力排序
2. dp1[i]的递推公式：考虑当前队伍 i 和前一个队伍能否匹配。
    - 若能匹配 dp1[i] = max(dp1[i-2] + 1, dp1[i-1])
    - 若不能匹配 dp1[i] = dp1[i-1]
3. dp2[i]的递推公式：考虑当前队伍 i 和前一个队伍能否匹配。
    - 若能匹配
        - 若dp1[i-2] + 1 > dp1[i-1]，dp2[i] = dp2[i-2] + 当前队伍与前一队伍的实力差值
        - 若dp1[i-2] + 1 < dp1[i-1]，dp2[i] = dp2[i-1] 
        - 若dp1[i-2] + 1 == dp1[i-1]，dp2[i] = min(dp2[i-2] + 当前队伍与前一队伍的实力差值, dp2[i-1])
    - 若不能匹配 dp2[i] = dp2[i-1]

## 解题代码
```python
def solve_method(n, d, nums):
    nums.sort()
    # 前i个队伍中，最多可以匹配的队伍数量
    dp1 = [0] * (n + 1)
    # 前i个队伍中，最多匹配的队伍数量对应的实力差值总和
    dp2 = [0] * (n + 1)
    for i in range(2, n+1):
        # 考虑当前队伍i-1是否和前一个队伍匹配
        if nums[i-1] - nums[i-2] <= d: # 匹配
            # 判断dp1[i]的取值
            if dp1[i-2] + 1 > dp1[i-1]:
                dp1[i] = dp1[i-2] + 1
                dp2[i] = dp2[i-2] + nums[i-1] - nums[i-2]
            elif dp1[i-2] + 1 < dp1[i-1]:
                dp1[i] = dp1[i-1]
                dp2[i] = dp2[i-1]
            else:
                dp1[i] = dp1[i-1]
                dp2[i] = min(dp2[i-2] + nums[i-1] - nums[i-2], dp2[i-1])
    if dp1[n] == 0:
        return -1
    minDiffsum = dp2[n]
    for i in range(1, n+1):
        if dp1[i] == dp1[n]:
            minDiffsum = min(dp2[i], minDiffsum)
    return minDiffsum

if __name__ == "__main__":
    # 6 30
    # 81 87 47 59 81 18
    n, d = map(int, input().split())
    nums = list(map(int, input().split()))
    print(solve_method(n, d, nums))

    assert solve_method(6, 30, [81, 87, 47, 59, 81, 18]) == 57
    assert solve_method(6, 20, [81, 87, 47, 59, 81, 18]) == 12
    assert solve_method(4, 10, [40, 51, 62, 73]) == -1
```