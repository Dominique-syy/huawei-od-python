# 256 硬件产品销售方案

## 题目描述

某公司目前推出了AI开发者套件、AI加速卡、AI加速模块、AI服务器、智能边缘多种硬件产品，每种产品包含若干个型号。现某合作厂商要采购金额为amount元的硬件产品搭建自己的AI基座。

假设当前库存有N种产品，每种产品的库存量充足，给定每种产品的价格，记为price（不存在价格相同的产品型号）。请为合作厂商列出所有可能的产品组合。

## 输入描述

输入包含采购金额 amount和产品价格列表price。第一行为amount，第二行为price。例如：
```
500
[100,200,300,500]
```

## 输出描述

输出为组合列表。例如：

`[[500], [200, 300], [100,200, 200], [100, 100,300], [100, 100, 100,200],[100,100,100, 100,100]]`

## 备注
1．对于给定输入，产品组合少于150种。输出的组合为一个数组，数组的每个元素也是一个数组，表示一种组合方案。如果给定产品无法组合金额为amount元的方案，那么返回空列表。

2．两种组合方案，只要存在一种产品的数量不同，那么方案认为是不同的。

3．每种产品型号价格不相同

4. 1＜＝产品类型数量＜＝30

5. 100＜＝产品价格＜＝20000

6. 100＜＝采购金额＜＝50000

## 示例描述

### 示例一

**输入：**
```text
500
[100, 200, 300, 500]
```

**输出：**
```text
[[100, 100, 100, 100, 100], [100, 100, 100, 200], [100, 100, 300], [100, 200, 200], [200, 300], [500]]
```

### 示例二

**输入：**
```text
100
[100]
```

**输出：**
```text
[[100]]
```

## 解题思路

**基本思路：**

递归解法：
- 从价格列表的第一个元素开始，判定若面值小于等于amount，加入当前组合中
- 用amount减去当前面值的价格，进行下一轮递归

为了避免重复：
- 引入`index`记录当前元素在列表中的位置 -> 递归时，只从当前元素开始的子列表进行
- 由于不存在价格相同的产品，所以无需额外的判断来避免重复

优化时间复杂度：
- 预先对价格列表排序，列表的第一个元素取值最小
- 截止条件2：若最小的面值都大于amount，说明没有解，直接返回

**代码思路：**
1. `prices`排序是为了优化时间复杂度
2. 递归的两个截止条件
   - 截止条件1：当前amount等于0，说明已经找到了一组解，将当前解存储在最终列表中，返回
   - 截止条件2：最小的面值都大于amount，说明没有解，直接返回
3. 递归的核心函数：
   - 遍历从当前位置开始的子列表（标记当前位置的目的：避免重复）
   - 若当前元素小于等于amout，加入组合
   - 从当前位置开始（每种产品可使用多次），进入下一轮递归

## 解题代码
```python
def solve_method(amount, prices):
    prices.sort()
    combinations = []
    dfs(prices, amount, 0, [], combinations)
    return combinations

def dfs(prices, amount, index, combination, combinations):
    # 截止条件1：当前amount等于0，说明已经找到了一组解，将当前解存储在最终列表中，返回
    if amount == 0:
        combinations.append(combination)
        return
    # 截止条件2：最小的面值都大于amount，说明没有解，直接返回
    if index >= len(prices) or prices[index] > amount:
        return
    for i in range(index, len(prices)):
        if(prices[i] <= amount):
            dfs(prices, amount - prices[i], i, combination + [prices[i]], combinations)

if __name__ == "__main__":
    # 500
    # [100, 200, 300, 500]
    amount = int(input().strip())
    prices = list(map(int, input().strip('[').strip(']').split(',')))
    print(solve_method(amount, prices))

    assert sorted(solve_method(500, [100, 200, 300, 500])) == sorted([[100, 100, 100, 100, 100], [100, 100, 100, 200], [100, 100, 300], [100, 200, 200], [200, 300], [500]])
    assert sorted(solve_method(100, [100])) == sorted([[100]])
```