https://wiki.amoscloud.com/zh/ProgramingPractice/NowCoder/Adecco/Topic0206
# 244 最优资源分配

## 题目描述

某块业务芯片最小容量单位为`1.25G`，总容量为`M * 1.25G`，对该芯片资源编号为`1,2, ..., M`。该芯片支持3种不同的配置，分别为`A、B、C`。
- 配置`A`：占用容量为`1.25 * 1 = 1.25G`
- 配置`B`：占用容量为`1.25 * 2 = 2.5G`
- 配置`C`：占用容量为`1.25 * 8 = 10G`

某块板卡上集成了`N`块上述芯片，对芯片编号为`1,2,...,N`，各个芯片之间彼此独立，不能跨芯片占用资源。

给定板卡上芯片数量`N`、每块芯片容量`M`、用户按次序配置后，请输出芯片资源占用情况，保证消耗的芯片数量最少。

- 资源分配规则：按照芯片编号从小到大分配所需资源，芯片上资源如果被占用标记为`1`，没有被占用标记为`0`。
- 用户配置序列：用户配置是按次序依次配置到芯片中，如果用户配置序列中某个配置超过了芯片总容量，丢弃该配置，继续遍历用户后续配置。

## 输入描述

`M`：每块芯片容量为`M * 1.25G`，取值范围为`1 ~ 256`

`N`：每块板卡包含芯片数量，取值范围为`1 ~ 32`

用户配置序列：例如`ACABA`，长度不超过`1000`

## 输出描述

板卡上每块芯片的占用情况

## 备注

用户配置是按次序依次配置到芯片中，如果用户配置序列中某个配置超过了芯片总容量，丢弃该配置，继续遍历用户后续配置。

## 示例描述

### 示例一

**输入：**
```text
8
2
ACABA
```

**输出：**
```text
11111000
11111111
```

**说明：**

用户第1个配置A：占用第1块芯片第1个资源，芯片占用情况为：
```
10000000
00000000
```
用户第2个配置C：第1块芯片剩余8.75G，配置C容量不够，只能占用第2块芯片，芯片占用情况为：
```
10000000
11111111
```
用户第3个配置A：第1块芯片剩余8.75G，还能继续配置，占用第1块芯片第2个资源，芯片占用情况为：
```
11000000
11111111
```
用户第4个配置B：第1块芯片剩余7.5G，还能继续配置，占用第1块芯片第3/4个资源，芯片占用情况为：
```
11110000
11111111
```
用户第5个配置A：第1块芯片剩余5G，还能继续配置，占用第1块芯片第5个资源，芯片占用情况为：
```
11110000
11111111
```

### 示例二

**输入：**
```text
8
2
ACBCB
```

**输出：**
```text
11111000
11111111
```

**说明：**

用户第1个配置A：占用第1块芯片第1个资源，芯片占用情况为：
```
10000000
00000000
```
用户第2个配置C：第1块芯片剩余8.75G，配置C容量不够，只能占用第2块芯片，芯片占用情况为：
```
10000000
11111111
```
用户第3个配置B：第1块芯片剩余8.75G，还能继续配置，占用第1块芯片第2、3个资源，芯片占用情况为：
```
11100000
11111111
```
用户第4个配置C：芯片资源不够，丢弃配置配置，继续下一个配置，本次配置后芯片占用情况保持不变：
```
11100000
11111111
```
用户第5个配置B：第1块芯片剩余6.25G，还能继续配置，占用第1块芯片第4、5个资源，芯片占用情况为：
```
11111000
11111111
```

## 解题思路

**基本思路：**

题目比较难理解，看示例说明。两个关键点：
- 资源分配规则：按芯片编号从小到大分配资源
- 若当前芯片容量，满足用户配置，占用该芯片；否则，遍历下一个芯片。
  （若没有芯片满足用户配置，舍弃该用户配置）

**代码思路：**
1. 外层循环：遍历所有用户配置
2. 内层循环：遍历各个芯片的容量，判定是否满足用户配置
3. 若满足用户配置，跳出内层循环，继续遍历下一个用户配置
4. 若不满足用户配置，继续遍历下一个芯片，直到找不到，舍弃该配置

## 解题代码
```python
def solve_method(M, N, config):
    cores = [M] * N
    used = [1, 2, 8]
    for c in config:
        cur = used[ord(c) - ord('A')]
        # 资源分配规则：按芯片编号从小到大分配资源
        for i in range(N):
            # 当前芯片容量，满足用户配置
            if cores[i] >= cur:
                cores[i] -= cur
                break
    return ['1' * (M - core) + '0' * core for core in cores]

if __name__ == "__main__":
    # 8
    # 2
    # ACABA
    M = int(input())
    N = int(input())
    config = input().strip()
    for core in solve_method(M, N, config):
        print(core)
    assert solve_method(8, 2, "ACABA") == ["11111000", "11111111"]
    assert solve_method(8, 2, "ACBCB") == ["11111000", "11111111"]
```