# 234 士兵过河

## 题目描述
一支`N`个士兵的军队正在趁夜色逃亡，途中遇到一条湍急的大河。

敌军在T的时长后到达河面，没到过对岸的士兵都会被消灭。

现在军队只找到了一只小船，这船最多能同时坐上2个士兵。

1）当一个士兵划船过河，用时为`a[i]`；`0 <= i < N`

2）当两个士兵坐船同时划船过河时，用时为 `max(a[j], a[i])` 两士兵中用时最长的。

3）当两个士兵坐船一个士兵划船时，用时为 `a[i] * 10` ; `a[i]` 为划船士兵用时。

4）如果士兵下河游泳，则会被湍急水流直接带走，算作死亡。


请帮忙给出一种解决方案，保证存活的士兵最多，且过河用时最短。

## 输入描述
第一行：N 表示士兵数(`0 < N < 1,000,000`)

第二行：T 表示敌军到达时长(`0 < T < 100,000,000`)

第三行：`a[0] a[1] … a[i] … a[N - 1]`

`a[i]` 表示每个士兵的过河时长。
(`10 < a[i] < 100; 0 < i < N`)

## 输出描述
第一行：“最多存活士兵数” “最短用时”

## 示例描述

### 示例一

**输入：**
```
5
43
12 13 15 20 50
```

**输出：**
```
3 40
```

**说明：** 
可以达到或小于43的一种方案：

第一步：`a[0] a[1]` 过河用时: `13`

第二步：`a[0]` 返回用时: `12`

第三步：`a[0] a[2]` 过河用时: `15`

### 示例二

**输入：**
```
5
130
50 12 13 15 20
```

**输出：**
```
5 128
```

**说明：** 
可以达到或小于130的一种方案：

第一步：`a[1] a[2]` 过河用时: `13`

第二步：`a[1]` 返回用时: `12`

第三步：`a[0] a[4]` 过河用时: `50`

第四步：`a[2]` 返回用时: `13`

第五步：`a[1] a[2]` 过河用时: `13`

第六步：`a[1]` 返回用时: `12`

第七步：`a[1] a[3]` 过河用时: `15`

### 示例三

**输入：**
```
7
171
25 12 13 15 20 35 20
```

**输出：**
```
7 171
```

**说明：** 
可以达到或小于171的一种方案：

第一步：`a[1] a[2]` 过河用时: `13`

第二步：`a[1]` 返回用时: `12`

第三步：`a[0] a[5]` 过河用时: `35`

第四步：`a[2]` 返回用时: `13`

第五步：`a[1] a[2]` 过河用时: `13`

第六步：`a[1]` 返回用时: `12`

第七步：`a[4] a[6]` 过河用时: `20`

第八步：`a[2]` 返回用时: `13`

第九步：`a[1] a[3]` 过河用时: `15`

第步：`a[1]` 返回用时: `12`

第步：`a[1] a[2]` 过河用时: `13`

**备注**
1）两个士兵同时划船时，如果划速不同会导致船原地转圈圈；所以为保持两个士兵划速相同，则需要向划的慢的士兵看齐。

2）两个士兵坐船时，重量增加吃水加深，水的阻力增大；同样的力量划船速度会变慢。

3）由于河水湍急大量的力用来抵消水流的阻力，所以 2）中过河时间不是 `a[i] * 2`，而是 `a[i] * 10`。

## 解题思路
1. 船只有一艘，需要有人来回送船
2. 两人过河最短过河时间为 `a[i] * 10` 与 `max(a[i], a[j])` 中的较小的值；
2. 需要士兵存活最多，可根据士兵渡河时间由小到大排序，若排序后过河时间短的士兵无法存活，则时间长的士兵可以不考虑存活；
4. 针对第i个士兵，计算其能否成功渡河，有两种情况，一种是a[i - 1]及之前的人均已渡河，一种是a[i - 1]之前的人已渡河，但a[i - 1]未渡河(船最多只能坐下两人，仅需考虑前一人)
    - 当 a[i - 1] 已渡河，则需考虑 a[0] 送船 + a[0] 和 a[i] 一起渡河的耗时
    - 当 a[i - 1] 未渡河，需要 a[0] 送船，a[i - 1] a[i] 一起渡河后 a[1] 送船，最终 a[0] a[1] 一起渡河的耗时

## 解题代码
``` python
def shorter_time(a, b):
    # 返回是一人划船 或 两人一起划船 耗时少的时间
    return a * 10 if a * 10 < b else b

def solve_method(N, T, a):
    # 耗时从小到大排序，以能存活更多人的方案为先
    a.sort()
    dp = [0] * N

    if a[0] > T:
        # 没有人能在敌军到达前过河
        return (0, 0)
    else:
        dp[0] = a[0]
        if N > 1:
            dp[1] = shorter_time(a[0], a[1])
            if dp[1] > T:
                # 两个人无法在敌军到达前完成过河
                return (1, dp[0])
            else:
                # 继续计算更多人需要过河时的耗时
                for i in range(2, N):
                    # 仅剩最后一人未过河的情况，让耗时最少的人划船回来，再计算两人如何划船过河合适
                    a1 = dp[i - 1] + a[0] + shorter_time(a[0], a[i])
                    # 剩两人的情况，需要两趟来回，需要 a0 和 a1 分别划船回来一次
                    a2 = dp[i - 2] + a[0] + shorter_time(a[i - 1], a[i]) + a[1] + shorter_time(a[0], a[1])
                    # 记录更短的那个时间
                    dp[i] = min(a1, a2)
                    if dp[i] > T:
                        return (i, dp[i - 1])
                        break
    return (N, dp[N - 1])
    
if __name__ == '__main__':
    a = [12, 13, 15, 20, 50]
    assert solve_method(5, 43, a) == (3, 40)

    a = [50, 12, 13, 15, 20]
    assert solve_method(5, 130, a) == (5, 128)

    a = [25, 12, 13, 15, 20, 35, 20]
    assert solve_method(7, 171, a) == (7, 171)
```