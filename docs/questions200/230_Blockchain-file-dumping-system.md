# 230 区块链文件转储系统

## 题目描述
区块链底层存储是一个链式文件系统，由顺序的 `N` 个文件组成，每个文件的大小不一，依次为$F_1, F_2, ... F_n$。随着时间的推移，所占存储会越来越大。

云平台考虑将区块链按文件转储到廉价的SATA盘，只有连续的区块链文件才能转储到SATA盘上，且转储的文件之和不能超过SATA盘的容量。

假设每块SATA盘容量为 `M`，求能转储的最大连续文件大小之和。
## 输入描述
第一行为SATA盘容量 `M`,  $1000 \leq M \leq 1000000$

第二行为区块链文件大小序列 $F_1, F_2, ... F_n$。

其中 $1 \leq n \leq 100000$， $1 \leq F_i \leq 500$


## 输出描述
求能转储的最大连续文件大小之和

## 示例描述

### 示例一

**输入：**
```
1000
100 300 500 400 400 150 100
```

**输出：**
```
950
```

**说明：** 
最大序列和为 `950`，序列为 `[400,400,150]`

### 示例二

**输入：**
```
1000
100 500 400 150 500 100
```

**输出：**
```
1000
```

**说明：** 
最大序列和为 `1000`，序列为 `[100,500,400]`

## 解题思路
**简单提示**
使用滑动窗口的思路，用两个指针 `l` 和 `r` 表示选中给的子文件集，进行遍历，记录不大于容量的最大连续子文件及的大小。

## 解题代码
``` python
import sys

def solve_method(M, files):
    l, r = 0, 0
    sum_, max_ = 0, 0
    while r < len(files):
        # 计算新的 子文件集 大小之和
        new_sum = sum_ + files[r]
        # 当前 子文件集的 大小之和 > 容量，则将 子文件集 中 第一个文件 删除
        while new_sum > M and l < r:
            if new_sum > M:
                sum_ -= files[l]
                new_sum -= files[l]
                l += 1

        # 当前 子文件集的 大小之和 < 容量，则添加 当前文件 到 子文件集中
        if new_sum < M:
            sum_ += files[r]
            r += 1
            # 记录 最大的 子文件集的 大小之和
            max_ = max(max_, sum_)
        elif new_sum == M:
            return M
    return max_

if __name__ == '__main__':
    file_sizes = [100, 300, 500, 400, 400, 150, 100]
    assert solve_method(1000, file_sizes) == 950
```