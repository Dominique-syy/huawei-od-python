# 003 通过软盘拷贝文件 

## 题目描述

有一名科学家想要从一台古董电脑中拷贝文件到自己的电脑中加以研究。但此电脑除了有一个3.5寸软盘驱动器以外，没有任何手段可以将文件持贝出来，而且只有一张软盘可以使用。因此这一张软盘是唯一可以用来拷贝文件的载体。科学家想要尽可能多地将计算机中的信息拷贝到软盘中，做到软盘中文件内容总大小最大。

已知该软盘容量为1474560字节。文件占用的软盘空间都是按块分配的，每个块大小为512个字节。一个块只能被一个文件使用。拷贝到软盘中的文件必须是完整的，且不能采取任何压缩技术。

## 输入描述

第1行是一个整数`N`，表示计算机中的文件数量，取值范围是1 <= N <= 1000。

接下来的第2行到第`N+1`行（共`N`行），每行为一个整数，表示每个文件的大小`Si`，单位为字节。取值范围是0 <= i <= N、0 <= Si <= 1000000。

## 输出描述

科学家最多能拷贝的文件总大小。

**备注：** 

为了充分利用软盘空间，将每个文件在软盘上占用的块记录到本子上，即真正占用软盘空间的只有文件内容本身。

## 示例描述

### 示例一

**输入：**
```text
3
737270
737272
737288
```

**输出：**
```text
1474542
```

**说明：**  

3个文件中，每个文件实际占用的大小分别为737280字节、737280字节、737792字节。

只能选取前两个文件，总大小为1474542字节。虽然后两个文件总大小更大且未超过1474560字节，但因为实际占用的大小超过了1474560字节，所以不能选后两个文件。

### 示例二

**输入：**
```text
6
400000
200000
200000
200000
400000
400000
```

**输出：**
```text
1400000
```

**说明：**  

从6个文件中，选择3个大小为400000的文件和1个大小为200000的文件，得到最大总大小为1400000。

也可以选择2个大小为400000的文件和3个大小为200000的文件，得到的总大小也是1400000。

## 解题思路

**基本思路：** 
这个问题是一个经典的0/1背包问题，其中目标是最大化在给定容量限制下的文件大小总和。我们可以通过动态规划的方法来解决这个问题。

1. **输入文件的数量和大小**：
   - 读取用户输入的文件数量。
   - 使用列表推导式来读取每个文件的大小。

2. **背包容量计算**：
   - 计算背包的容量，它是以512字节块为单位的。

3. **初始化动态规划数组**：
   - 初始化一个二维数组`dp`，其中`dp[i][j]`表示前`i`个文件在容量为`j`的背包中可以达到的最大文件大小。

4. **动态规划过程**：
   - 我们通过所有文件，对每个文件，我们计算其大小（以512字节块为单位）和其实际大小（字节）。
   - 然后，我们遍历所有可能的背包容量，对每个背包容量，我们有两个选择：要么放入当前文件（如果它可以适应），要么不放入。我们选择可以使背包中的总文件大小最大的那个选项。
   
5. **结果输出**：
   - 最后，我们打印可以存储的最大文件大小，这可以通过查看`dp[n][W]`获得，其中`n`是文件数量，`W`是背包的容量。

通过这个策略，我们可以有效地找到给定容量限制下可以存储的最大文件大小。

## 解题代码
```python
import math

# 读取文件的数量
n = int(input())

# 使用列表推导式来读取每个文件的大小
nums = [int(input()) for _ in range(n)]

# 计算背包的容量（以512字节块为单位）
W = 1474560 // 512

# 初始化动态规划数组，其中dp[i][j]存储前i个文件在容量为j的背包中可以达到的最大文件大小
dp = [[0] * (W + 1) for _ in range(n + 1)]

# 循环通过所有文件
for i in range(1, n + 1):

    # 计算当前文件的大小（以512字节块为单位）和实际大小（字节）
    size, value = math.ceil(nums[i - 1] / 512), nums[i - 1]

    # 遍历所有可能的背包容量
    for j in range(W + 1):

        # 如果当前文件可以放入背包（即其大小小于或等于当前背包容量），我们可以选择放入或不放入文件
        if size <= j:
            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - size] + value)
        else:
            # 如果当前文件太大而无法放入背包，我们只能选择不放入文件
            dp[i][j] = dp[i - 1][j]

# 打印结果：在给定容量限制下，可以存储的最大文件大小
print(dp[n][W])
```