# 001 树状结构查询

## 题目描述

通常使用多行的节点、父节点表示一棵树，比如：
```text
西安 陕西
陕西 中国
江西 中国
中国 亚洲
泰国 亚洲
```

输入一个节点之后，请打印出来树中该节点的所有下层节点。

## 输入描述

第一行输入行数。

下面是多行数据，每行以空格区分节点和父节点。

接着是查询节点。

## 输出描述

输出查询节点的所有下层节点。以字典序排序。

**补充说明：**

树中的节点是唯一的，不会出现两个节点，是同一个名字。

## 示例描述

### 示例一

**输入：**
```text
5
b a
c a
d c
e c
f d
c
```

**输出：**
```text
d
e
f
```

## 解题思路

**基本思路：** 

1. **初始化树结构**：使用一个字典来表示树结构，其中键是节点，值是一个列表，包含该节点的所有直接子节点。

2. **读取和存储节点对**：读取用户输入的节点对，并更新树结构。使用 setdefault 方法可以很方便地将子节点添加到父节点的列表中。


3. **目标节点的子节点检索**：首先从树结构中获取目标节点的直接子节点列表。然后使用一个循环来执行广度优先搜索（BFS），在每次迭代中，我们取出一个节点，并将其所有子节点添加到列表的末尾，以便稍后检查。这个过程会一直持续，直到没有更多的节点要检查。

4. **排序和打印结果**：最后，我们将结果列表排序（以确保输出的顺序是一致的）并打印每个子节点。

5. **返回结果**：虽然当前的函数实现没有返回任何值（它只是打印结果），但如果需要，可以轻松地修改它来返回结果列表，而不是打印它。

通过上述步骤，我们可以成功找到并打印目标节点的所有子节点。
## 解题代码
```python
def split_str(s):
    """将字符串's'按空格分割并返回结果列表。"""
    return s.split()


def main():
    """主函数，用于处理树结构并打印目标节点的子节点。"""

    # 初始化一个空字典来存储树结构
    tree = {}

    # 从用户那里获取节点的数量
    n = int(input("输入节点的数量: "))

    # 读取每个节点并更新树结构
    for _ in range(n):
        a, b = split_str(input("输入由空格分隔的节点对: "))
        tree.setdefault(b, []).append(a)

    # 从用户那里获取目标节点
    target = input("输入目标节点: ")

    # 检索目标节点的子节点
    children = tree.get(target, [])
    result = []

    while children:
        node = children.pop(0)
        result.append(node)
        children.extend(tree.get(node, []))

    # 对结果进行排序并打印
    result.sort()
    for res in result:
        print(res)


# 运行主函数
if __name__ == "__main__":
    main()
```